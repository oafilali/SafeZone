pipeline {
    agent any
    
    parameters {
        choice(
            name: 'DEPLOYMENT_TARGET',
            choices: ['AWS', 'Local Docker', 'Both'],
            description: 'Choose deployment target'
        )
        booleanParam(
            name: 'SKIP_TESTS',
            defaultValue: false,
            description: 'Skip test execution (not recommended for production)'
        )
        booleanParam(
            name: 'SKIP_FRONTEND_BUILD',
            defaultValue: false,
            description: 'Skip frontend build (backend changes only)'
        )
        booleanParam(
            name: 'FORCE_REBUILD',
            defaultValue: false,
            description: 'Force clean rebuild (ignore cache)'
        )
        string(
            name: 'CUSTOM_TAG',
            defaultValue: '',
            description: 'Custom Docker tag (leave empty for build number)'
        )
        string(
            name: 'SONARQUBE_URL_OVERRIDE',
            defaultValue: 'https://unfudged-cristie-meristic.ngrok-free.dev',
            description: 'Providing an ngrok URL permits remote Jenkins (AWS) to talk to your local SonarQube'
        )
        string(
            name: 'SONAR_TOKEN_OVERRIDE',
            defaultValue: '',
            description: 'Override SonarQube token (leave empty to use Jenkins credentials)'
        )
        booleanParam(
            name: 'REQUIRE_CODE_REVIEW',
            defaultValue: true,
            description: 'Require manual code review approval before production deployment (main branch only)'
        )
    }
    
    triggers {
        githubPush()  // Trigger on GitHub webhook push
    }

    options {
        // Keep last 30 builds
        buildDiscarder(logRotator(numToKeepStr: '30'))
        // Prevent concurrent builds
        disableConcurrentBuilds()
    }

    environment {
        // Load configuration from external file
        MAVEN_HOME = '/opt/apache-maven-3.9.9'
        NODEJS_HOME = '/usr/bin'
        PATH = "${MAVEN_HOME}/bin:${NODEJS_HOME}:${env.PATH}"
        
        // Email Configuration - Use credentials for sensitive data
        TEAM_EMAIL = credentials('team-email')  // Store in Jenkins Credentials
        
        // AWS Configuration - Use credentials for sensitive data
        AWS_DEPLOY_HOST = credentials('aws-deploy-host')  // Store in Jenkins Credentials
        AWS_DEPLOY_USER = credentials('aws-deploy-user')  // Store in Jenkins Credentials
        // AWS_SSH_KEY is handled via withCredentials block for proper Secret File binding
        
        // MongoDB Credentials - Use credentials for sensitive data
        MONGO_ROOT_USERNAME = credentials('mongo-root-username')  // Store in Jenkins Credentials
        MONGO_ROOT_PASSWORD = credentials('mongo-root-password')  // Store in Jenkins Credentials
        
        // API Gateway URL - REQUIRED for deployment
        API_GATEWAY_URL = credentials('api-gateway-url')  // Store in Jenkins Credentials
        
        // SonarQube Configuration
        SONARQUBE_AWS_URL = "http://${AWS_DEPLOY_HOST}:9000"
        SONARQUBE_LOCAL_URL = "http://localhost:9000"
        // SONARQUBE_TOKEN will be set in SonarQube Analysis stage with withCredentials block
        
        // Docker Configuration
        DOCKER_IMAGE_PREFIX = 'buy01-pipeline'
        SERVICE_REGISTRY_IMAGE = 'buy01-pipeline-service-registry'
        API_GATEWAY_IMAGE = 'buy01-pipeline-api-gateway'
        USER_SERVICE_IMAGE = 'buy01-pipeline-user-service'
        PRODUCT_SERVICE_IMAGE = 'buy01-pipeline-product-service'
        MEDIA_SERVICE_IMAGE = 'buy01-pipeline-media-service'
        FRONTEND_IMAGE = 'buy01-pipeline-frontend'
        
        // Paths
        JENKINS_SCRIPTS = './.pipeline/jenkins'
        FRONTEND_DIR = 'buy-01-ui'
        
        // Code Review & PR Configuration
        GITHUB_TOKEN = credentials('github-token')  // Store in Jenkins Credentials
        IS_PULL_REQUEST = "${env.CHANGE_ID != null}"
        TARGET_BRANCH = "${env.CHANGE_TARGET ?: env.GIT_BRANCH ?: 'main'}"
        SOURCE_BRANCH = "${env.CHANGE_BRANCH ?: env.GIT_BRANCH ?: 'main'}"
    }

    stages {
        stage('Initialize') {
            steps {
                script {
                    // Logic to handle automated triggers (which don't allow parameter selection)
                    echo "Checking trigger context for branch: ${env.GIT_BRANCH}"
                    
                    // Detect Pull Request context
                    if (env.IS_PULL_REQUEST == "true") {
                        echo "üìù PULL REQUEST DETECTED #${env.CHANGE_ID}"
                        echo "  Source: ${env.SOURCE_BRANCH}"
                        echo "  Target: ${env.TARGET_BRANCH}"
                    } else {
                        echo "üìã Regular branch build: ${env.GIT_BRANCH}"
                    }
                    
                    // Use deployment target from parameters
                    env.FINAL_TARGET = params.DEPLOYMENT_TARGET
                    
                    // Determine which SonarQube URL to use
                    if (params.SONARQUBE_URL_OVERRIDE != "") {
                        env.FINAL_SONAR_URL = params.SONARQUBE_URL_OVERRIDE.trim()
                        echo "üîç Using SonarQube Override (ngrok): ${env.FINAL_SONAR_URL}"
                    } else if (env.FINAL_TARGET == 'Local Docker') {
                        env.FINAL_SONAR_URL = env.SONARQUBE_LOCAL_URL
                    } else {
                        env.FINAL_SONAR_URL = env.SONARQUBE_AWS_URL
                    }
                    
                    // Determine which SonarQube Token to use
                    if (params.SONAR_TOKEN_OVERRIDE != "") {
                        env.FINAL_SONAR_TOKEN = params.SONAR_TOKEN_OVERRIDE.trim()
                        echo "üîë Using SonarQube Token Override"
                    } else {
                        // Token will be loaded via withCredentials in SonarQube Analysis stage
                        echo "üîë Using SonarQube Token from Jenkins Credentials"
                    }
                    
                    echo "üéØ Final Deployment Target: ${env.FINAL_TARGET}"
                    echo "üéØ Final SonarQube URL: ${env.FINAL_SONAR_URL}"
                    echo "üîê Code Review Required: ${params.REQUIRE_CODE_REVIEW}"
                }
            }
        }

        stage('Validate Environment') {
            steps {
                echo 'Validating build environment...'
                sh "${JENKINS_SCRIPTS}/validate-environment.sh"
            }
        }
        
        stage('Checkout') {
            options {
                timeout(time: 10, unit: 'MINUTES')
            }
            steps {
                checkout scm
            }
        }

        stage('Build Backend') {
            options {
                timeout(time: 30, unit: 'MINUTES')
            }
            steps {
                echo 'Building backend services with tests for coverage...'
                script {
                    if (params.FORCE_REBUILD) {
                        sh 'mvn clean install -U'  // Force update dependencies and run tests
                    } else {
                        sh 'mvn clean install'  // Run tests to generate coverage data
                    }
                }
            }
        }
        
        stage('Test Frontend') {
            when {
                expression { !params.SKIP_TESTS }
            }
            options {
                timeout(time: 20, unit: 'MINUTES')
            }
            steps {
                echo 'Running frontend tests...'
                dir('buy-01-ui') {
                    sh '''
                        set -e
                        mkdir -p target/surefire-reports
                        
                        # Detect Chrome binary location
                        export CHROME_BIN=$(which chromium-browser || which google-chrome || which chrome || echo "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome" 2>/dev/null || echo "")
                        
                        if [ -z "$CHROME_BIN" ] || [ ! -f "$CHROME_BIN" ]; then
                            echo "‚ùå Error: Chrome not found! Frontend tests cannot be executed."
                            echo "To fix: Install Chrome/Chromium on the build agent or set CHROME_BIN environment variable."
                            exit 1
                        fi
                        
                        echo "Using Chrome: $CHROME_BIN"
                        npm test -- --watch=false --browsers=ChromeHeadless --code-coverage
                        if [ $? -ne 0 ]; then
                            echo "‚ùå Frontend tests FAILED! Pipeline will STOP here."
                            exit 1
                        fi
                        echo "‚úÖ Frontend tests completed with code coverage"
                    '''
                }
            }
        }
        
        
        stage('SonarQube Analysis') {
            when {
                expression { !params.SKIP_TESTS }
            }
            options {
                timeout(time: 20, unit: 'MINUTES')
            }
            steps {
                echo '=========================================='
                echo 'üîç Running SonarQube Code Analysis...'
                echo '=========================================='
                script {
                    echo "Using SonarQube at: ${env.FINAL_SONAR_URL}"
                    
                    // Prepare PR-specific parameters if this is a pull request
                    def prParams = ""
                    if (env.IS_PULL_REQUEST == "true") {
                        prParams = "-Dsonar.pullrequest.key=${env.CHANGE_ID} -Dsonar.pullrequest.branch=${env.SOURCE_BRANCH} -Dsonar.pullrequest.base=${env.TARGET_BRANCH}"
                        echo "üìù Configuring PR analysis for pull request #${env.CHANGE_ID}"
                    }
                    
                    // Load SonarQube token based on whether we're using override or Jenkins credentials
                    if (params.SONAR_TOKEN_OVERRIDE?.trim()) {
                        // Use override token if provided
                        env.FINAL_SONAR_TOKEN = params.SONAR_TOKEN_OVERRIDE.trim()
                        echo "üîë Using SonarQube Token Override"
                        
                        withSonarQubeEnv('SonarQube') {
                            // 1. Scan the Backend (Java Microservices)
                            sh "mvn sonar:sonar ${prParams} -Dsonar.host.url='${env.FINAL_SONAR_URL}' -Dsonar.token='${env.FINAL_SONAR_TOKEN}'"
                            
                            // 2. Scan the Frontend (Angular)
                            sh """
                                mvn sonar:sonar -N ${prParams} \
                                    -Dsonar.projectKey=safezone-frontend \
                                    -Dsonar.projectName="SafeZone Frontend" \
                                    -Dsonar.sources=buy-01-ui/src \
                                    -Dsonar.tests=buy-01-ui/src \
                                    -Dsonar.test.inclusions=**/*.spec.ts \
                                    -Dsonar.coverage.exclusions=**/*.spec.ts,**/node_modules/**,**/dist/** \
                                    -Dsonar.typescript.lcov.reportPaths=buy-01-ui/coverage/lcov.info \
                                    -Dsonar.host.url='${env.FINAL_SONAR_URL}' \
                                    -Dsonar.token='${env.FINAL_SONAR_TOKEN}'
                            """
                        }
                    } else {
                        // Use Jenkins credential
                        echo "üîë Using SonarQube Token from Jenkins Credentials"
                        withCredentials([string(credentialsId: 'jedi-sonarqube-ngrok-token', variable: 'SONAR_TOKEN_VAR')]) {
                            env.FINAL_SONAR_TOKEN = env.SONAR_TOKEN_VAR
                            
                            withSonarQubeEnv('SonarQube') {
                                // 1. Scan the Backend (Java Microservices)
                                sh "mvn sonar:sonar ${prParams} -Dsonar.host.url='${env.FINAL_SONAR_URL}' -Dsonar.token='${env.FINAL_SONAR_TOKEN}'"
                                
                                // 2. Scan the Frontend (Angular)
                                sh """
                                    mvn sonar:sonar -N ${prParams} \
                                        -Dsonar.projectKey=safezone-frontend \
                                        -Dsonar.projectName="SafeZone Frontend" \
                                        -Dsonar.sources=buy-01-ui/src \
                                        -Dsonar.tests=buy-01-ui/src \
                                        -Dsonar.test.inclusions=**/*.spec.ts \
                                        -Dsonar.coverage.exclusions=**/*.spec.ts,**/node_modules/**,**/dist/** \
                                        -Dsonar.typescript.lcov.reportPaths=buy-01-ui/coverage/lcov.info \
                                        -Dsonar.host.url='${env.FINAL_SONAR_URL}' \
                                        -Dsonar.token='${env.FINAL_SONAR_TOKEN}'
                                """
                            }
                        }
                    }
                }
            }
        }
        
        stage('Quality Gate') {
            when {
                expression { !params.SKIP_TESTS }
            }
            options {
                timeout(time: 20, unit: 'MINUTES')
            }
            steps {
                echo '=========================================='
                echo 'üö¶ Checking SonarQube Quality Gate...'
                echo '=========================================='
                script {
                    // Use manual Quality Gate check for ngrok URLs since the Jenkins plugin uses cached server config
                    echo "üïµÔ∏è Using Manual Quality Gate Check (ngrok tunnel detected)..."
                    
                    // Wait a moment for report file flush
                    sleep 5
                    
                    if (fileExists('target/sonar/report-task.txt')) {
                        def props = readProperties file: 'target/sonar/report-task.txt'
                        def serverUrl = props['serverUrl']
                        def taskId = props['ceTaskId']
                        
                        echo "Checking task: ${taskId} at ${serverUrl}"
                        
                        // Load the token again since we're in a new stage
                        if (params.SONAR_TOKEN_OVERRIDE?.trim()) {
                            env.FINAL_SONAR_TOKEN = params.SONAR_TOKEN_OVERRIDE.trim()
                        } else {
                            withCredentials([string(credentialsId: 'jedi-sonarqube-ngrok-token', variable: 'SONAR_TOKEN_VAR')]) {
                                env.FINAL_SONAR_TOKEN = env.SONAR_TOKEN_VAR
                                pollQualityGate(serverUrl, taskId)
                            }
                            return
                        }
                        
                        pollQualityGate(serverUrl, taskId)
                    } else {
                        echo "‚ö†Ô∏è Report file not found. Skipping Quality Gate check."
                    }
                }
            }
        }

        stage('Parallel Build & Test') {
            options {
                timeout(time: 45, unit: 'MINUTES')
            }
            parallel {
                stage('Backend Tests') {
                    when {
                        expression { !params.SKIP_TESTS }
                    }
                    steps {
                        echo 'Running JUnit tests...'
                        sh '''
                            set -e
                            mvn test
                        '''
                    }
                    post {
                        always {
                            junit '**/target/surefire-reports/*.xml'
                        }
                    }
                }
                
                stage('Frontend Pre-check') {
                    when {
                        expression { !params.SKIP_FRONTEND_BUILD }
                    }
                    steps {
                        echo 'Checking frontend dependencies...'
                        dir('buy-01-ui') {
                            // Only run install if we need it for tests later, 
                            // but Docker handles the main build
                            sh 'npm install --legacy-peer-deps'
                        }
                    }
                }
            }
        }
        
        stage('Code Review Approval') {
            when {
                allOf {
                    expression { env.IS_PULL_REQUEST != "true" }  // Only for regular branches
                    expression { env.TARGET_BRANCH == 'main' || env.TARGET_BRANCH == 'master' }  // Only for main/master
                    expression { params.REQUIRE_CODE_REVIEW == true }  // Only if enabled
                    expression { !params.SKIP_TESTS }  // Only if tests weren't skipped
                }
            }
            options {
                timeout(time: 24, unit: 'HOURS')
            }
            steps {
                echo '=========================================='  
                echo 'üë• Code Review & Approval Required'
                echo '=========================================='
                echo "Build: ${env.JOB_NAME} #${env.BUILD_NUMBER}"
                echo "Branch: ${env.GIT_BRANCH}"
                echo "Commit: ${env.GIT_COMMIT?.take(8)}"
                echo ""
                echo "Please review the code quality:"
                echo "  üìä SonarQube Analysis: ${env.FINAL_SONAR_URL}/projects"
                echo "  üìà Test Results: ${env.BUILD_URL}testReport"
                echo "  üì¶ Build Logs: ${env.BUILD_URL}console"
                echo ""
                
                script {
                    try {
                        input(
                            id: 'CodeReviewApproval',
                            message: '''===========================================
üë• CODE REVIEW APPROVAL GATE
===========================================

Do you approve this code for production deployment?

Please verify:
‚úì Code changes are well-tested
‚úì SonarQube quality gates passed
‚úì No critical security issues
‚úì Code follows team standards
‚úì Documentation is updated

Reviewer Action: APPROVE or REJECT
==========================================''',
                            ok: '‚úÖ APPROVE FOR DEPLOYMENT',
                            submitter: 'safezone-reviewers'
                        )
                        echo "‚úÖ Code Review APPROVED"
                    } catch (err) {
                        echo "‚ùå Code Review REJECTED or TIMEOUT"
                        echo "Reason: ${err.message}"
                        error("Code review approval required before deployment to production")
                    }
                }
            }
        }
        
        stage('Deploy') {
            when {
                expression { env.IS_PULL_REQUEST != "true" }  // Skip deployment for PRs
            }
            options {
                timeout(time: 60, unit: 'MINUTES')
            }
            steps {
                script {
                    // Logic for Local Deployment
                    if (env.FINAL_TARGET == 'Local Docker' || env.FINAL_TARGET == 'Both') {
                        echo '=========================================='
                        echo 'üöÄ Deploying locally via Docker Compose...'
                        echo '=========================================='
                        sh '''
                            # Build Docker images
                            ./.pipeline/jenkins/build-docker-images.sh ${BUILD_NUMBER}
                            
                            # Start services locally
                            export MONGO_ROOT_USERNAME=${MONGO_ROOT_USERNAME}
                            export MONGO_ROOT_PASSWORD=${MONGO_ROOT_PASSWORD}
                            export API_GATEWAY_URL=${API_GATEWAY_URL}
                            cd .pipeline && docker compose --file docker-compose.yml up -d && cd ..
                        '''
                        echo "‚úÖ Local deployment successful!"
                    }

                    // Logic for AWS Deployment
                    if (env.FINAL_TARGET == 'AWS' || env.FINAL_TARGET == 'Both') {
                        echo 'Deploying application to AWS...'
                        // Create production .env file from Jenkins credentials
                        // This ensures secrets are available on AWS even though ignored in Git
                        sh """
                            echo "Generating production environment file..."
                            echo "MONGO_ROOT_USERNAME=${MONGO_ROOT_USERNAME}" > .pipeline/.env.production
                            echo "MONGO_ROOT_PASSWORD=${MONGO_ROOT_PASSWORD}" >> .pipeline/.env.production
                            echo "API_GATEWAY_URL=${API_GATEWAY_URL}" >> .pipeline/.env.production
                            echo "AWS_DEPLOY_HOST=${AWS_DEPLOY_HOST}" >> .pipeline/.env.production
                            echo "AWS_DEPLOY_USER=${AWS_DEPLOY_USER}" >> .pipeline/.env.production
                        """
                        
                        sh '''
                            # Make scripts executable
                            chmod +x ${JENKINS_SCRIPTS}/*.sh
                            
                            # Pre-deployment cleanup
                            ${JENKINS_SCRIPTS}/pre-deployment-cleanup.sh
                            
                            # Build Docker images
                            ${JENKINS_SCRIPTS}/build-docker-images.sh ${BUILD_NUMBER}
                        '''
                        
                        // Try AWS deployment first
                        def awsDeploymentSuccessful = false
                        
                        // Use withCredentials to properly bind the SSH key and SSL certs
                        withCredentials([
                        file(credentialsId: 'aws-ssh-key-file', variable: 'AWS_SSH_KEY_FILE'),
                        file(credentialsId: 'frontend-ssl-cert', variable: 'SSL_CERT_FILE'),
                        file(credentialsId: 'frontend-ssl-key', variable: 'SSL_KEY_FILE')
                        ]) {
                            try {
                                echo '=========================================='
                                echo 'üöÄ Deploying to AWS...'
                                echo 'üöÄ Transferring SSL Certificates...'
                                echo '=========================================='
                                sh '''
                                    export AWS_SSH_KEY="${AWS_SSH_KEY_FILE}"
                                    chmod 600 "${AWS_SSH_KEY}"
                                    
                                    # Ensure remote certs directory exists
                                    ssh -i "${AWS_SSH_KEY}" -o StrictHostKeyChecking=no "${AWS_DEPLOY_USER}@${AWS_DEPLOY_HOST}" "sudo mkdir -p /home/${AWS_DEPLOY_USER}/buy-01-app/certs && sudo chown -R ${AWS_DEPLOY_USER}:${AWS_DEPLOY_USER} /home/${AWS_DEPLOY_USER}/buy-01-app && sudo chmod -R 755 /home/${AWS_DEPLOY_USER}/buy-01-app"
                                    # Transfer SSL certificates as expected by Nginx config
                                    scp -i "${AWS_SSH_KEY}" -o StrictHostKeyChecking=no "${SSL_CERT_FILE}" "${AWS_DEPLOY_USER}@${AWS_DEPLOY_HOST}:/home/${AWS_DEPLOY_USER}/buy-01-app/certs/localhost.pem"
                                    scp -i "${AWS_SSH_KEY}" -o StrictHostKeyChecking=no "${SSL_KEY_FILE}" "${AWS_DEPLOY_USER}@${AWS_DEPLOY_HOST}:/home/${AWS_DEPLOY_USER}/buy-01-app/certs/localhost-key.pem"
                                    
                                    ${JENKINS_SCRIPTS}/deploy.sh ${BUILD_NUMBER}
                                '''
                                awsDeploymentSuccessful = true
                                
                                // Post-deployment cleanup on success
                                sh '${JENKINS_SCRIPTS}/post-deployment-cleanup.sh'
                            } catch (Exception e) {
                                echo "‚ö†Ô∏è AWS Deployment failed: ${e.message}"
                            echo "Reason: Typically SSH key not found or AWS credentials unavailable"
                            awsDeploymentSuccessful = false
                            
                            // Attempt rollback INSIDE withCredentials so it has access to the SSH key
                            try {
                                echo "Rolling back changes..."
                                sh '''
                                    export AWS_SSH_KEY="${AWS_SSH_KEY_FILE}"
                                    chmod 600 "${AWS_SSH_KEY}"
                                    ${JENKINS_SCRIPTS}/rollback.sh
                                '''
                            } catch (Exception rollbackError) {
                                echo "‚ö†Ô∏è Rollback also failed: ${rollbackError.message}"
                            }
                        }
                    }
                }
            }
        }
    }
}

    post {
        always {
            echo '=========================================='
            echo 'Publishing test results...'
            echo '=========================================='
            
            // Parse backend JUnit reports
            junit(
                testResults: '**/target/surefire-reports/*.xml',
                allowEmptyResults: true
            )
            
            // Archive test reports
            archiveArtifacts(
                artifacts: '**/target/surefire-reports/**/*.xml',
                allowEmptyArchive: true,
                fingerprint: true
            )
            
            // Archive coverage reports if they exist
            archiveArtifacts(
                artifacts: '**/target/site/jacoco/**/*,buy-01-ui/coverage/**/*',
                allowEmptyArchive: true,
                fingerprint: true
            )
        }
        success {
            echo '=========================================='
            echo '‚úÖ Pipeline completed successfully!'
            echo '=========================================='
            
            script {
                try {
                    def template = readFile("${JENKINS_SCRIPTS}/email-success.html")
                    def emailBody = template
                        .replace('${BUILD_URL}', env.BUILD_URL ?: '')
                        .replace('${BUILD_NUMBER}', env.BUILD_NUMBER ?: '')
                        .replace('${JOB_NAME}', env.JOB_NAME ?: '')
                        .replace('${BUILD_DURATION}', currentBuild.durationString ?: '')
                        .replace('${BUILD_TIMESTAMP}', new Date().format('yyyy-MM-dd HH:mm:ss'))
                        .replace('${GIT_BRANCH}', env.GIT_BRANCH ?: 'main')
                    mail(
                        subject: "‚úÖ BUILD SUCCESS: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                        body: emailBody,
                        to: "${TEAM_EMAIL}",
                        mimeType: 'text/html'
                    )
                } catch (Exception e) {
                    echo "‚ö†Ô∏è Email notification failed: ${e.message}"
                }
            }
        }
        failure {
            echo '=========================================='
            echo '‚ùå Pipeline failed! Immediate action required'
            echo '=========================================='
            
            script {
                try {
                    def template = readFile("${JENKINS_SCRIPTS}/email-failure.html")
                    def emailBody = template
                        .replace('${BUILD_URL}', env.BUILD_URL ?: '')
                        .replace('${BUILD_NUMBER}', env.BUILD_NUMBER ?: '')
                        .replace('${JOB_NAME}', env.JOB_NAME ?: '')
                        .replace('${BUILD_DURATION}', currentBuild.durationString ?: '')
                        .replace('${BUILD_TIMESTAMP}', new Date().format('yyyy-MM-dd HH:mm:ss'))
                        .replace('${GIT_BRANCH}', env.GIT_BRANCH ?: 'main')
                    mail(
                        subject: "‚ùå BUILD FAILED: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                        body: emailBody,
                        to: "${TEAM_EMAIL}",
                        mimeType: 'text/html'
                    )
                } catch (Exception e) {
                    echo "‚ö†Ô∏è Email notification failed: ${e.message}"
                }
            }
        }
        unstable {
            echo '‚ö†Ô∏è Pipeline unstable - some tests may have failed'
            
            script {
                try {
                    def template = readFile("${JENKINS_SCRIPTS}/email-unstable.html")
                    def emailBody = template
                        .replace('${BUILD_URL}', env.BUILD_URL ?: '')
                        .replace('${BUILD_NUMBER}', env.BUILD_NUMBER ?: '')
                        .replace('${JOB_NAME}', env.JOB_NAME ?: '')
                        .replace('${BUILD_DURATION}', currentBuild.durationString ?: '')
                        .replace('${BUILD_TIMESTAMP}', new Date().format('yyyy-MM-dd HH:mm:ss'))
                        .replace('${GIT_BRANCH}', env.GIT_BRANCH ?: 'main')
                    mail(
                        subject: "‚ö†Ô∏è BUILD UNSTABLE: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                        body: emailBody,
                        to: "${TEAM_EMAIL}",
                        mimeType: 'text/html'
                    )
                } catch (Exception e) {
                    echo "‚ö†Ô∏è Email notification failed: ${e.message}"
                }
            }
        }
    }
}

// Helper function to poll SonarQube Quality Gate with token authentication
void pollQualityGate(String serverUrl, String taskId) {
    // 1. Poll for Task Completion
    timeout(time: 5, unit: 'MINUTES') {
        waitUntil {
            script {
                // Use curl with the token
                def taskStatus = sh(
                    script: "curl -s -u '${env.FINAL_SONAR_TOKEN}:' '${serverUrl}/api/ce/task?id=${taskId}' | grep -o '\"status\":\"[^\"]*\"' | cut -d: -f2 | tr -d '\"'",
                    returnStdout: true
                ).trim()
                
                echo "Current Task Status: ${taskStatus}"
                return (taskStatus == 'SUCCESS' || taskStatus == 'FAILED' || taskStatus == 'CANCELED')
            }
        }
    }
    
    // 2. Poll for Quality Gate Status
    def analysisId = sh(
        script: "curl -s -u '${env.FINAL_SONAR_TOKEN}:' '${serverUrl}/api/ce/task?id=${taskId}' | grep -o '\"analysisId\":\"[^\"]*\"' | cut -d: -f2 | tr -d '\"'",
        returnStdout: true
    ).trim()
    
    if (analysisId) {
        // Extract only the first status (project status), ignoring condition statuses
        def qgStatus = sh(
            script: "curl -s -u '${env.FINAL_SONAR_TOKEN}:' '${serverUrl}/api/qualitygates/project_status?analysisId=${analysisId}' | grep -o '\"status\":\"[^\"]*\"' | head -n 1 | cut -d: -f2 | tr -d '\"'",
            returnStdout: true
        ).trim()
        
        echo "Quality Gate Status: ${qgStatus}"
        
        if (qgStatus != 'OK') {
            error "‚ùå Quality Gate FAILED: ${qgStatus}"
        } else {
            echo "‚úÖ Quality Gate passed!"
        }
    } else {
        echo "‚ö†Ô∏è Could not retrieve Analysis ID via manual check."
    }
}
